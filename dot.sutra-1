// Dot

/*
Simple pseudocode

if LEFT, column --
if RIGHT, column --

if UP:

row_data = row_data << 1

if row_data == 0100000000:
    row_data = 0000000001
    row_bank++

if DOWN:

row_data = row_data >> 1
if row_data == 0:
    row_data = 0010000000
    row_bank--


select row and column   01<row bank:2><column index>
row data                10<data:8>
load buffer             1100000000
*/


# DEFINE COLUMN_ROW_BANK_INDEX_ADDRESS      69420
# DEFINE ROW_DATA_ADDRESS                   69422
# DEFINE LOAD_BUFFER_COMMAND                b1100000000

// setup at center of screen
//32/2 = 16
//0..7 
//8..15

// 2nd bank, col 31
LOADI_UNSIGNED B b0101011111
//LOADI_UNSIGNED B b0101111101
// last pixel of bank (row 15)
LOADI_UNSIGNED C b1010000000

:render
// Save
//LOADMARI COLUMN_ROW_BANK_INDEX_ADDRESS
//STORE B

//LOADMARI ROW_DATA_ADDRESS
//STORE C

//Output
OUT B
OUT C
LOADI_UNSIGNED D LOAD_BUFFER_COMMAND
OUT D

:right

//add +1 to B
LOADI A 1
ALUFSETO ADD
ALUEVAL B
ALUSTORER B

:updatecol

//add back first 4 numbers

/*
xxxx011000
0000111111
1111100111 NAND
0000011000 Complement Result
0101000000 ADD following
0101011000

steps:
1.NAND with 0000111111 and compliment result
2. ADD 0101000000

6 - OC
5 - N
4 - Cin
3 - BC
2 - BZ
1 - AC
0 - AZ

*/

LOADI A b0000111111
ALUFSET 1100000
ALUEVAL B
ALUSTORER B

LOADI A b0101000000
ALUFSETO ADD
ALUEVAL B
ALUSTORER B

OUT B
OUT C
OUT D

J :right


:left

//sub -1 from B
// AZ, AC -> 111... + B = B - 1
ALUFSET 0000011   
ALUEVAL B
ALUEVAL B


:up
// right shift 
/*
steps:
1. NAND with 0011111111 and compliment result
2. Right/Left shift by 1
3. if 0 then 
    add 0010000000 or 0000000001
    increase/decrease row_bank (?)
*/
     



HALT









